> from django.contrib.auth import get_user_model
> from django.utils.text import slugify
> from rest_framework import permissions, status, viewsets
> from rest_framework.authtoken.models import Token
> from rest_framework.decorators import action
> from rest_framework.response import Response
> from rest_framework.throttling import AnonRateThrottle
> from rest_framework.views import APIView
> from .models import User, Address, UserProfile, EmailVerificationToken
> from .serializers import UserSerializer, AddressSerializer, UserProfileSerializer
  
  
> class AuthRateThrottle(AnonRateThrottle):
>     scope = 'auth'
  
  
> class RegisterView(APIView):
>     permission_classes = [permissions.AllowAny]
>     throttle_classes = [AuthRateThrottle]
  
>     def post(self, request):
>         email = (request.data.get('email') or '').strip().lower()
>         password = request.data.get('password') or ''
  
>         if not email:
!             return Response({'email': ['This field is required.']}, status=status.HTTP_400_BAD_REQUEST)
>         if not password:
!             return Response({'password': ['This field is required.']}, status=status.HTTP_400_BAD_REQUEST)
  
>         UserModel = get_user_model()
>         if UserModel.objects.filter(email=email).exists():
!             return Response({'email': ['A user with this email already exists.']}, status=status.HTTP_400_BAD_REQUEST)
  
>         base_username = slugify(email.split('@')[0]) or 'user'
>         username = base_username
>         suffix = 2
>         while UserModel.objects.filter(username=username).exists():
!             username = f"{base_username}{suffix}"
!             suffix += 1
  
>         user = UserModel(email=email, username=username)
>         user.set_password(password)
>         user.save()
  
          # Create verification token
>         verification_token = EmailVerificationToken.create_token(user)
  
>         token, _ = Token.objects.get_or_create(user=user)
  
>         return Response(
>             {
>                 'token': token.key,
>                 'user': UserSerializer(user).data,
>                 'verification_token': verification_token.token,  # In production, send via email
>                 'message': 'Registration successful. Please verify your email.',
>             },
>             status=status.HTTP_201_CREATED,
>         )
  
  
> class UserViewSet(viewsets.ModelViewSet):
>     queryset = User.objects.all()
>     serializer_class = UserSerializer
>     permission_classes = [permissions.IsAuthenticated]
      
>     def get_queryset(self):
>         return User.objects.filter(id=self.request.user.id).order_by('id')
  
>     @action(detail=False, methods=['post'])
>     def change_password(self, request):
>         """Change user password."""
>         user = request.user
>         old_password = request.data.get('old_password', '')
>         new_password = request.data.get('new_password', '')
  
>         if not old_password:
>             return Response({'old_password': ['This field is required.']}, status=status.HTTP_400_BAD_REQUEST)
>         if not new_password:
>             return Response({'new_password': ['This field is required.']}, status=status.HTTP_400_BAD_REQUEST)
  
>         if not user.check_password(old_password):
>             return Response({'old_password': ['Current password is incorrect.']}, status=status.HTTP_400_BAD_REQUEST)
  
>         if len(new_password) < 8:
>             return Response({'new_password': ['Password must be at least 8 characters.']}, status=status.HTTP_400_BAD_REQUEST)
  
>         user.set_password(new_password)
>         user.save()
  
>         return Response({'message': 'Password changed successfully.'}, status=status.HTTP_200_OK)
  
>     @action(detail=False, methods=['post'])
>     def send_verification_email(self, request):
>         """Send email verification token (resend)."""
>         user = request.user
          
>         if user.is_verified:
>             return Response({'message': 'Email is already verified.'}, status=status.HTTP_400_BAD_REQUEST)
  
          # Invalidate old tokens
>         EmailVerificationToken.objects.filter(user=user, is_used=False).update(is_used=True)
          
          # Create new token
>         verification_token = EmailVerificationToken.create_token(user)
          
          # In production, send this via email
>         return Response({
>             'message': 'Verification email sent.',
>             'verification_token': verification_token.token  # Remove in production
>         }, status=status.HTTP_200_OK)
  
>     @action(detail=False, methods=['post'], permission_classes=[permissions.AllowAny])
>     def verify_email(self, request):
>         """Verify email with token."""
>         token_string = request.data.get('token', '').strip()
          
>         if not token_string:
>             return Response({'error': 'Token is required.'}, status=status.HTTP_400_BAD_REQUEST)
  
>         try:
>             token = EmailVerificationToken.objects.get(token=token_string)
>         except EmailVerificationToken.DoesNotExist:
>             return Response({'error': 'Invalid token.'}, status=status.HTTP_400_BAD_REQUEST)
  
>         if not token.is_valid():
>             return Response({'error': 'Token has expired or already been used.'}, status=status.HTTP_400_BAD_REQUEST)
  
          # Mark token as used
>         token.is_used = True
>         token.save()
  
          # Mark user as verified
>         user = token.user
>         user.is_verified = True
>         user.save()
  
>         return Response({
>             'message': 'Email verified successfully.',
>             'user': UserSerializer(user).data
>         }, status=status.HTTP_200_OK)
  
  
> class AddressViewSet(viewsets.ModelViewSet):
>     serializer_class = AddressSerializer
>     permission_classes = [permissions.IsAuthenticated]
      
>     def get_queryset(self):
>         return Address.objects.filter(user=self.request.user).order_by('-created_at', '-id')
  
>     def perform_create(self, serializer):
>         serializer.save(user=self.request.user)
  
>     def perform_update(self, serializer):
>         serializer.save(user=self.request.user)
  
  
> class UserProfileViewSet(viewsets.ModelViewSet):
>     serializer_class = UserProfileSerializer
>     permission_classes = [permissions.IsAuthenticated]
      
>     def get_queryset(self):
>         return UserProfile.objects.filter(user=self.request.user).order_by('-created_at', '-id')
  
>     def perform_create(self, serializer):
>         serializer.save(user=self.request.user)
  
>     def perform_update(self, serializer):
!         serializer.save(user=self.request.user)
